{"meta":{"title":"Hexo","subtitle":"","description":"Test description","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"SSM","date":"2020-04-16T10:53:58.000Z","updated":"2020-04-16T10:53:58.337Z","comments":true,"path":"SSM/index.html","permalink":"http://yoursite.com/SSM/index.html","excerpt":"","text":""},{"title":"Hexo","date":"2020-04-15T13:44:33.000Z","updated":"2020-04-15T13:44:33.511Z","comments":true,"path":"Hexo/index.html","permalink":"http://yoursite.com/Hexo/index.html","excerpt":"","text":""},{"title":"关于我","date":"2020-04-15T12:58:00.000Z","updated":"2020-04-15T13:05:01.690Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"我是YInkit，一名来自深圳的学生，很高兴你长这么帅还愿意关注我。"},{"title":"数据结构","date":"2020-04-15T13:16:13.000Z","updated":"2020-04-15T13:16:13.328Z","comments":true,"path":"数据结构/index.html","permalink":"http://yoursite.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-04-15T14:01:55.000Z","updated":"2020-04-15T14:01:55.219Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Matlab","slug":"Matlab","date":"2020-04-19T09:14:32.000Z","updated":"2020-04-24T07:19:49.221Z","comments":true,"path":"2020/04/19/Matlab/","link":"","permalink":"http://yoursite.com/2020/04/19/Matlab/","excerpt":"因备赛學習，學習教程來源於台大郭彦甫老師，学习中…","text":"因备赛學習，學習教程來源於台大郭彦甫老師，学习中… 1、簡介 1.1、Background Matrix Laboratory（矩陣實驗室） A high level programming language Many useful toolboxes(工具) and built- in functions(內部函數) Easy visualization（簡單地可視化） 1.2、The Primary Aim of the Course Provide the students with the background and necessary experience [by way of lots of practice（通過大量的練習）] to Use MATALB Write programs Solve engineering problems 1.3、Schedule 2、MATLAB計算機與矩陣操作2.1、Ready to launch（初步認識） 1、MATLAB Programming Modes（編程模式） Command line(in command window) Scripts(.m files) 2、MATLAB as A Calculator Operators : + - * / ^ Result is computed,and displayed as ans Precedence rules(優先規則): Left-to-right within a precedence group Precedence groups are (highest first): Parenthesis() [括號] Power(^) Multiplication and division(*,/) [乘法和除法] Addition and subtraction(+,-) 3、Exercise 1234&gt;&gt; cos(((1+2+3+4)^3&#x2F;5)^0.5)&gt;&gt; sin((pi)^0.5)+log(tan(1))&gt;&gt; 2^(3.5*1.7)&gt;&gt; exp(sin(10)) 2.2、Elementary Math Functions (基本數學函數)通過百度 or Google去查~ Function list: Arithmetic（算法） Trigonometry（三角函數） Exponents and Logarithms（指數和對數） Complex Numbers（複數） Cartesian Coordinate System Conversion（笛卡爾坐標系轉換） 1、Embedding Functions（嵌入函數） Functions may be embedded into other functions Many lines of code can be condensed into one single command（許多代碼可以壓縮成一個命令） 2、Variables（變數） Variables do NOT need to be declared(聲明) before assignment(賦值) A single “equal” sign (=) is the assignment operator: Question： Upper case/lower case make difference?（ 大写字母/小写字母有区别吗?） 答：是不一樣的變數 Can variable names can begin with a number? 1 2A = 10 //不OK A2 = 10 //OK 1 3、Numeric Variable (Data) Type （數據類型）注：MATLAB數據類型默認為Double 12345678910111213&#x2F;&#x2F;通過who可得到varibles訊息&gt;&gt; whoYour variables are:A2 ans &#x2F;&#x2F;通過whos可得到更詳細的訊息，包括數據類型&gt;&gt; whos Name Size Bytes Class Attributes A2 1x1 8 double ans 1x1 8 double 4、Special Variables and Constant（特殊變數與常數）keyword（關鍵字）： ans i , j：complex number Inf：∞ *eps *：2.204e-016 Nan：not a number pi：π 5、MATLAB Calling Priority（調用優先級） 例如： 123456&gt;&gt; cos&#x3D;&#39;this string.&#39;;&gt;&gt; cos(8)ans &#x3D; &#39;r&#39; 6、Numeric Display “Format”（數字顯示的類型）12通過fromat xx&gt;&gt; fromat long 7、Command Line Terminal Observe the difference between 123456789&#x2F;&#x2F;顯示運算結果&gt;&gt; a &#x3D; 10a &#x3D; 10&#x2F;&#x2F;不顯示運算結果&gt;&gt; b &#x3D; 10; ; at the end of a command suppresses(抑制) output to the terminal(終端) ↑ display previous commands 8、Some Functions clc：clear command window display clear：remove all variables in the workspace who：variables in the workspace whos： variable information of the workspace 9、Array[Vector and Matrix(向量和矩陣)] Row vector: 1&gt;&gt; a &#x3D; [1,2,3,4] Column vector: 1&gt;&gt; b &#x3D; [1;2;3;4] formula operation result &gt;&gt; a*b 1+4+9+16 = 30 &gt;&gt; b*a 1 2 3 4 2 4 6 8 3 6 9 12 4 8 12 16 Key in the following matrix in MATLAB: formula operation result &gt;&gt;[1 21 6;5 17 9;31 2 7] 1 21 65 17 931 2 7 10、Array Indexing Select a certain subset of elements inside a matrix What’s the answer from MATLAB after typing? 方法一： formula operation result A(1) 1 A(2) 5 A(3) 31 A(4) 21 方法二： formula operation rsult &gt;&gt; A(3,2) 2 &gt;&gt; A([1 3],[1 3]) 1 631 7 11、Colon Operator(冒號運算法“ : ”) Want to create a long array:A = [1 2 3…100] Creates vectors or arrays,and specify for iterations Syntax: Delete rows of columns of A： 12、Array Concatenation(連接) Arrays can be formed through concatenation as long as the rectngular shape is preserved(只要保持网格形状，就可以通过连接形成阵列) 1234567&gt;&gt; A&#x3D;[1 2;3 4];&gt;&gt; B&#x3D;[9 9;9 9];&gt;&gt; F&#x3D;[A B]F &#x3D; 1 2 9 9 3 4 9 9 1234567&gt;&gt; F&#x3D;[A;B]F &#x3D; 1 2 3 4 9 9 9 9 13、Array Manipulation(數組操作) A*B A.*B B’ … 14、Some Special Matrix(特殊矩陣) 15、Some Matrix Related Functions 計算圖式：","categories":[],"tags":[]},{"title":"MyBatis","slug":"MyBatis","date":"2020-04-16T10:53:03.000Z","updated":"2020-04-19T09:32:49.552Z","comments":true,"path":"2020/04/16/MyBatis/","link":"","permalink":"http://yoursite.com/2020/04/16/MyBatis/","excerpt":"SSM框架MyBatis的学习笔记，学习中…","text":"SSM框架MyBatis的学习笔记，学习中… 1.简介1.1、什么是MyBatis MyBatis 是一款优秀的持久层框架 它支持自定义 SQL、存储过程以及高级映射。 MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。 MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。 2013年11月迁移到Github。 如何获得Mybatis？ Maven仓库 123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt;&lt;/dependency&gt; Github：https://github.com/mybatis/mybatis-3/releases 中文文档：https://mybatis.org/mybatis-3/zh/index.html 1.2 、持久化数据持久化 持久化就是将程序的数据在持久状态和瞬时状态转化的过程 内存：断电即失 数据库（jdbc）、io文件持久化。 生活中：冷藏、罐头… 为什么需要持久化？ 有一些对象，不然能让他丢掉。 内存太贵了 1.3、持久层Dao层，Server层，Controller层… 完成持久化工作的代码块 层界限十分明显。 1.4、为什么需要MyBatis？ 帮助程序员将数据存入到数据库中 方便 传统JDBC代码太复杂了。简化。框架。自动化。 不用Mybatis也可以。更容易上手。技术没有高低之分 优点： 简单易学 灵活 sql和代码的分离，提高了可维护性。 提供映射标签，支持对象与数据库的orm字段关系映射 提供对象关系映射标签，支持对象关系组建维护 提供xml标签，支持编写动态sql。 最重要的一点：使用的人多！ Spring、SpringMAV、SpringBoot 2、第一个Mybatis程序思路：搭建环境–&gt;导入Mybatis–&gt;编写代码–&gt;测试！ 2.1、搭建环境搭建数据库 123456789101112131415create database mybatis;use mybatisCREATE TABLE user ( id int not null primary key, name varchar(30) default null, pwd varchar(30) default null )ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8; INSERT INTO user (id,name,pwd) VALUES (1,&#39;狂神&#39;,&#39;123456&#39;), (2,&#39;张三&#39;,&#39;123456&#39;), (3,&#39;李四&#39;,&#39;123890&#39;); 新建项目 新建一个普通的maven项目 删除src目录 导入maven依赖 12345678910111213141516171819202122&lt;!-- 导入依赖 --&gt;&lt;dependencies&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.26&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis --&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.2、创建一个模块 编写mybatis的核心配置文件 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true%amp;useUnicode=true&amp;amp;characterEncoding=UTF-8\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"org/mybatis/example/BlogMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写mybatis工具类 123456789101112131415161718192021222324//sqlSessionFactory --&gt; sqlSeesionpublic class MybatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; &#123; try &#123; //使用Mybatis第一步：获取sqlSessionFactory对象 String resource = \"org/mybatis/example/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。 //SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。 public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(); &#125;&#125; 2.3编写代码 实体类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//实体类public class User &#123; private int id; private String name; private String pwd; public User()&#123; &#125; public User(int id,String name,String pwd)&#123; this.id = id; this.name = name; this.pwd = pwd; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", pwd='\" + pwd + '\\'' + '&#125;'; &#125;&#125; Dao接口 123public interface UserDao &#123; List&lt;User&gt; getUserList();&#125; 接口实现类由原来的UserDaolmpl转换为一个Mapper配置文件 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt;&lt;mapper namespace=\"com.kuang.dao.UserDao\"&gt; &lt;!--select查询语句--&gt; &lt;select id=\"getUserList\" resultType=\"com.kuang.pojo.User\"&gt; select * from mybatis.user &lt;/select&gt;&lt;/mapper&gt; 2.4、测试注意点： org.apache.ibatis.binding.BindingException: Type interface com.kuang.dao.UserDao is not known to the MapperRegistry. MapperRegistry是什么？ 核心配置文件中注册 mappers junit测试 12345678910111213141516171819@Testpublic void test()&#123; //第一步：获得SqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //方式一：getMapper UserDao userDao = sqlSession.getMapper(UserDao.class); List&lt;User&gt; userList = userDao.getUserList(); for (User user : userList) &#123; System.out.println(user); &#125; //关闭SqlSession sqlSession.close();&#125; 你们可以能会遇到的问题： 配置文件没有注册 绑定接口错误。 方法名不对 返回类型不对 Maven导出资源问题 3、CRUD1、namespacenamespace中的包名要和 Dao/mapper 接口的包名一致！ 2、select选择，查询语句; id : 就是对应的namespace中的方法名； resultType：Sql语句执行的返回值！ parameterType ： 参数类型！ 编写接口 12//根据ID查询用户User getUserById(int id); 编写对应的mapper中的sql语句 123&lt;select id=\"getUserById\" parameterType=\"int\" resultType=\"com.kuang.pojo.User\"&gt; select * from mybatis.user where id = #&#123;id&#125;&lt;/select&gt; 测试 1234567891011@Testpublic void getUserById() &#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); sqlSession.close();&#125; 3、Insert1234&lt;!--对象中的属性，可以直接取出来--&gt;&lt;insert id=\"addUser\" parameterType=\"com.kuang.pojo.User\"&gt; insert into mybatis.user (id, name, pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);&lt;/insert&gt; 4、update123&lt;update id=\"updateUser\" parameterType=\"com.kuang.pojo.User\"&gt; update mybatis.user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125; ;&lt;/update&gt; 5、Delete123&lt;delete id=\"deleteUser\" parameterType=\"int\"&gt; delete from mybatis.user where id = #&#123;id&#125;;&lt;/delete&gt; 注意点： 增删改需要提交事务！ 6、分析错误 标签不要匹配错 resource 绑定mapper，需要使用路径！ 程序配置文件必须符合规范！ NullPointerException，没有注册到资源! 输出的xml文件中存在中文乱码问题！ maven资源没有导出问题！ 7、万能Map假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map！ 12//万能的Mapint addUser2(Map&lt;String,Object&gt; map); 1234&lt;!--对象中的属性，可以直接取出来 传递map的key--&gt;&lt;insert id=\"addUser\" parameterType=\"map\"&gt; insert into mybatis.user (id, pwd) values (#&#123;userid&#125;,#&#123;passWord&#125;);&lt;/insert&gt; 123456789101112131415@Testpublic void addUser2()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"userid\",5); map.put(\"passWord\",\"2222333\"); mapper.addUser2(map); sqlSession.close();&#125; Map传递参数，直接在sql中取出key即可！ 【parameterType=”map”】 对象传递参数，直接在sql中取对象的属性即可！【parameterType=”Object”】 只有一个基本类型参数的情况下，可以直接在sql中取到！ 多个参数用Map，或者注解！ 8.思考题模糊查询怎么写？ 模糊查询怎么写？ Java代码执行的时候，传递通配符 % % 1List&lt;User&gt; userList = mapper.getUserLike(\"%李%\"); 在sql拼接中使用通配符！ 1select * from mybatis.user where name like \"%\"#&#123;value&#125;\"%\" 9、Lombok12Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more. java library plugs build tools with one annotation your class 使用步骤: 在IDEA中安装Lombok插件 在项目中导入lombok的jar包 12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt;&lt;/dependency&gt; 在实体类上加注解即可！ 123@Data：无参构造，get、set、tostring、hashcode，equals@AllArgsConstructor@NoArgsConstructor 1234567891011121314@Getter and @Setter@FieldNameConstants@ToString@EqualsAndHashCode@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger@Data@Builder@Singular@Delegate@Value@Accessors@Wither@SneakyThrows 4、配置解析1.核心配置 mybatis-config.xml MyBatis的配置文件包含了会深深影响MyBatis行为的设置和属性信息。 12345678910111213configuration（配置）properties（属性）settings（设置）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境配置）environment（环境变量）transactionManager（事务管理器）dataSource（数据源）databaseIdProvider（数据库厂商标识）mappers（映射器）","categories":[],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"}]},{"title":"树","slug":"树","date":"2020-04-15T13:17:28.000Z","updated":"2020-04-19T09:32:43.361Z","comments":true,"path":"2020/04/15/树/","link":"","permalink":"http://yoursite.com/2020/04/15/%E6%A0%91/","excerpt":"树的学习笔记，学习中…","text":"树的学习笔记，学习中… 树一、树结构概述二、二叉树2.1、什么是二叉树二叉树：任何一个节点的子节点数量不超过2 叉树的子节点分为左节点和右节点 2.1.1满二叉树满二叉树：所有叶子节点都在最后一层，而且所有节点的总数为2^n-1（n为树的高度） 2.1.2完全二叉树完全二叉树：所有叶子节点都在最后一层或倒数第二层，且最后一层的叶子结点在左边连续，倒数第二节点的叶子结点在右边连续 注：满二叉树一定是完全二叉树 2.2、链式存储的二叉树 创建二叉树、添加节点 树的遍历 查找节点：前序查找、中序查找、后序查找 删除节点 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class BinaryTree &#123; TreeNode root; //设置根节点 public void setRoot(TreeNode root) &#123; this.root = root; &#125; //获取根节点 public TreeNode getRoot() &#123; return root; &#125; public void frontShow() &#123; if(root!=null) &#123; root.frontShow(); &#125; &#125; public void midShow() &#123; if(root!=null) &#123; root.midShow(); &#125; &#125; public void afterShow() &#123; if(root!=null) &#123; root.afterShow(); &#125; &#125; public TreeNode frontSearch(int i) &#123; return root.frontSearch(i); &#125; public void delete(int i) &#123; if(root.value==i) &#123; root=null; &#125;else &#123; root.delete(i); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class TreeNode &#123; //节点的权 int value; //左儿子 TreeNode leftNode; //右儿子 TreeNode rightNode; public TreeNode(int value) &#123; this.value=value; &#125; //设置左二子 public void setLeftNode(TreeNode leftNode) &#123; this.leftNode = leftNode; &#125; //设置右儿子 public void setRightNode(TreeNode rightNode) &#123; this.rightNode = rightNode; &#125; //前序遍历 public void frontShow() &#123; //先遍历当前节点的内容 System.out.println(value); //左节点 if(leftNode!=null) &#123; leftNode.frontShow(); &#125; //右节点 if(rightNode!=null) &#123; rightNode.frontShow(); &#125; &#125; //中序遍历 public void midShow() &#123; //左节点 if(leftNode!=null) &#123; leftNode.midShow(); &#125; //当前节点的内容 System.out.println(value); //右节点 if(rightNode!=null) &#123; rightNode.midShow(); &#125; &#125; public void afterShow() &#123; //左节点 if(leftNode!=null) &#123; leftNode.afterShow(); &#125; //右节点 if(rightNode!=null) &#123; rightNode.afterShow(); &#125; //当前节点的内容 System.out.println(value); &#125; //前序查找 public TreeNode frontSearch(int i) &#123; TreeNode target=null; //对比当前节点的值 if(this.value==i) &#123; return this; //当前节点的值不是要查找的节点 &#125;else &#123; //查找左儿子 if(leftNode!=null) &#123; //有可能可以查到，也可能查不到 target = leftNode.frontSearch(i); &#125; //如果不为空，说明在左儿子中已经找到 if(target!=null) &#123; return target; &#125; //查找右儿子 if(rightNode!=null) &#123; target=rightNode.frontSearch(i); &#125; &#125; return target; &#125; //删除一个子树 public void delete(int i) &#123; TreeNode parent = this; //判断左儿子 if(parent.leftNode!=null&amp;&amp;parent.leftNode.value==i) &#123; parent.leftNode=null; return; &#125; //判断右儿子 if(parent.rightNode!=null&amp;&amp;parent.rightNode.value==i) &#123; parent.rightNode=null; return; &#125; //递归检查并删除左儿子 parent=leftNode; if(parent!=null) &#123; parent.delete(i); &#125; //递归检查并删除右儿子 parent=rightNode; if(parent!=null) &#123; parent.delete(i); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839//测试类public class TestBinaryTree &#123; public static void main(String[] args) &#123; //创建一棵树 BinaryTree binTree = new BinaryTree(); //创建一个根节点 TreeNode root = new TreeNode(1); //把根节点赋给树 binTree.setRoot(root); //创建一个左节点 TreeNode rootL = new TreeNode(2); //把新创建的节点设置为根节点的子节点 root.setLeftNode(rootL); //创建一个右节点 TreeNode rootR = new TreeNode(3); //把新创建的节点设置为根节点的子节点 root.setRightNode(rootR); //为第二层的左节点创建两个子节点 rootL.setLeftNode(new TreeNode(4)); rootL.setRightNode(new TreeNode(5)); //为第二层的右节点创建两个子节点 rootR.setLeftNode(new TreeNode(6)); rootR.setRightNode(new TreeNode(7)); //前序遍历树 binTree.frontShow(); System.out.println(\"----------\"); //中序遍历 binTree.midShow(); System.out.println(\"----------\"); //后序遍历 binTree.afterShow(); //前序查找 TreeNode result = binTree.frontSearch(3); System.out.println(result); //删除一个节点 binTree.delete(4); binTree.frontShow(); &#125;&#125; 2.3、顺序存储的二叉树","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"搭建博客","slug":"十分钟快速搭建个人博客","date":"2020-04-13T13:17:28.000Z","updated":"2020-04-15T14:08:17.267Z","comments":true,"path":"2020/04/13/十分钟快速搭建个人博客/","link":"","permalink":"http://yoursite.com/2020/04/13/%E5%8D%81%E5%88%86%E9%92%9F%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"通过Hexo+GitHub，快速搭建Blog！","text":"通过Hexo+GitHub，快速搭建Blog！ 准备工作 安装Node.js点击此处进入官网下载，进行安装即可。 安装Git点击此处进入官网下载，进行安装即可。 验证Node.js和Git是否安装成功通过运行命令（win+R）,输入cmd。可以通过node -v的命令来测试Node.JS是否安装成功可以通过git --version的命令来测试Git是否安装成功 安装Hexo创建一个文件夹，命名随意，进入文件夹后，右键选择“Git Bash here”。输入命令行，安装： 1npm install -g hexo-cli 查看一下版本: 1hexo -v 接下来初始化一下hexo 12//这个myblog可以自己取什么名字都行hexo init myblog 12//进入这个myblog文件夹cd myblog 1npm install 新建完成后，指定文件夹目录下有： node_modules: 依赖包public：存放生成的页面scaffolds：生成文章的一些模板source：用来存放你的文章themes：主题_config.yml: 博客的配置文件 打开hexo的服务，在浏览器输入localhost:4000就可以看到你生成的博客了 12hexo ghexo server 注册Github点击此处进入官网进行注册：注册好后，点击右上角的“New repository”创建一个新的仓库输入仓库名：你的Github用户名.github.io。然后点击‘’Create repository”。 特别注意的是：你的仓库名一定要和你的github用户名一模一样，不然后面会显示不出来。 接着进入刚刚创建好的仓库，点击右上角的“setting”点击选择模板随便选择一个模板即可（因为我们后面要使用hexo的模板）：现在打开你刚刚创建的github的静态网址：用户名.github.io，你会发现，就是你刚刚选择的模板页面。 在 Github 上添加 SSH key 配置SSH Key 打开命令行输入 1cd ~/.ssh 如果没报错或者提示什么的说明就是以前生成过的，直接使用命令就可以查看本机上的 SSH key 了。 12//xx指生成的秘钥文件名cat ~/.ssh/xx.pub 如果之前没有生成过SSH，就按照下面的方法生成。首先先登录一下。在命令行输入下面的指令，用户名和邮箱填写你自己真实的信息。 12git config --global user.name \"用户名\"git config --global user.email \"邮箱地址\" 然后就开始生成密钥 1ssh-keygen -t rsa -C '上面填写的邮箱地址' 根据提示按三次回车就会生成你电脑的SSH密钥，将其复制下来。首次使用的话还要确认并添加到可信任列表，输入下列指令： 1ssh -T git@github.com 最后在.ssh目录下(C盘用户文件夹下)得到了两个文件：xx（私有秘钥）和xx.pub（公有密钥） 部署到Github回到github，点击右上角头像，选择”Settings”点击左下栏的”SSH and GPG keys”点击“New SSH key”将秘钥用笔记本打开，复制到“key”中直接点击“Add SSH key”添加即可，标题不用写。 将本地部署到GitHub 将Hexo和GitHub关联起来将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为szyinkit24就是你的GitHub账户 1234deploy: type: git repo: https://github.com/szyinkit24/szyinkit24.github.io.git branch: master 部署到Github这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。 1npm install hexo-deployer-git --save 123hexo cleanhexo generatehexo deploy hexo clean 清除了你之前生成的东西，可以不加。 hexo generate 生成静态文章，可以缩写为 hexo ghexo deploy 部署文章，可以缩写为 hexo d 注意deploy时可能要你输入username和password。 过一会儿就可以在 http://用户名.github.io 这个网站看到你的博客了！！ 开始创作这种博客写作的时候特别容易，也是使用Markdown写的。如果不会用这种语法可以百度，用CSDN自带的文章编辑器也可以。新建文章有两种方法，第一种是执行下面的指令： 1hexo new '你想起的文章标题' 执行完以后你就会在/souce/-posts 文件夹下看到一个“你想起的文章标题.md”的文件了 第二种方法就是直接在/souce/-posts 文件夹下新建一个文本文档，命名为“文章标题.md”，这种方法是比较简单的。 文章编辑好了以后，再执行以下指令就可以了 12hexo cleanhexo g -d 稍等一会你就能看见你的文章了！！！","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]}],"categories":[],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]}